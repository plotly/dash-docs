The first step in deploying your Dash app to Dash Enterprise is to
prepare your application's code with the necessary files
required to deploy your Dash app.

This guide aimed at users who already have Dash apps running locally. 
If you haven't already created a Dash app yet, we recommend trying out 
Dash Enterprise Sample Apps & Templates. Every sample app and template is deploy ready and contains all of the 
necessary configuration files. 
{url_sample_app}

## Quickstart Checklist

Consider the following items to ensure that your application will be successfully deployed on Dash Enterprise:

1. **`Procfile`** - Ensure that your project folder has a `Procfile`. See [Application Structure](/dash-enterprise/application-structure) for details. This is often:
  ```
  web: gunicorn app:server --workers 2
 ```
3. **`requirements.txt`** - Ensure that your project folder has a `requirements.txt` file with the Python dependencies and versions. Don't forgot `gunicorn`! See [Application Structure Documentation](/dash-enterprise/application-structure) for details.
4. **`server = app.server`** - Declare the underlying `server` variable to be referenced by the `web` command in your `Procfile`. See [Application Structure Documentation](/dash-enterprise/application-structure) for details.
5. **Remove secrets & passwords** - Remove sensitive passwords and API keys from your code and replace them with [Environment Variables](/dash-enterprise/environment-variables).
6. **System-Level dependencies** - If your project requires system level dependencies like database drivers, then install those dependencies with a `predeploy` script and an `apt-packages` file.  See [Application Structure Documentation](/dash-enterprise/application-structure).
7. **Self-contained** - Ensure that all files and datasets that the application code references or saves are within the same project folder. 
8. **Initialize** your app in the Dash Enterprise App Manager UI. See [Part 2. Initialize Dash Apps on Dash Enterprise](/dash-enterprise/initialize).
9. **Deploy** your app by running the `git` instructions generated by the App Manager. See [Part 3. Deploy Dash Apps on Dash Enterprise](/dash-enterprise/deployment).


## Additional Considerations


### Dash Enterprise Workspaces

There are frequently many difference between your local environment and 
the containerized environment Dash Enterprise runs your app in.

This can include differences in:

- Operating system and the available drivers and package dependencies
- Networking
- Redis & Postgres
- Python packages - The versions that are installed and available for the operating system
- Authentication logic
- Server resources (RAM, CPU, Disk)
- Timeouts
- Git

Workspaces run on the Dash Enterprise server with a build system that is nearly identical to
how Dash apps are built and deployed. This means that the differences listed above do not
apply between Workspaces and deployed apps.

The easiest way to troubleshoot your application is to run it within a Dash Enterprise Workspace.
This can be done in two ways:

1. Deploying the app and creating a Workspace from that deployed application.
   This can only be done if the deployment succeeds.
2. Copying or uploading the files from your local environment to a new Dash Enterprise Workspace.

{url_workspaces} 

### Networking Differences: Local vs Deployed

After deploying your app to Dash Enterprise, you may notice
your app feels slower than when running it locally.

Dash Apps deployed on Dash Enterprise are on a
different network than Dash apps running locally.
This can affect the performance of callbacks and the
performance of any data fetching being done within your callback.

**Callback Performance**

The input, output, and state of a callback is transferred over the network.
When working locally, this data transfer is very fast.
When the application is deployed on a server, it takes longer to 
transfer the data from the user's browser to your callback and from your
callback to the user's browser.

This is usually not noticable unless your callbacks have large data structures
as inputs (e.g. a dataframe stored in `dcc.Store` or the contents of a `dcc.Upload` component)
or as outputs (e.g. large `figure` properties of `dcc.Graph` or large `data` properties of `DataTable`).

**Diagnosing Callback Network Performance Issues**

To investigate whether the performance issues are related to the network, we recommend:
- Viewing the `data transfer (avg bytes)` and `time - network` of callbacks via the [Dash Dev Tools Callback Graph](/devtools). You can turn this on for your deployed application with:
  ```
  app.enable_dev_tools(
      dev_tools_ui=True,
      dev_tools_serve_dev_bundles=True,
  )
  ```
- Using the Network Panel of your browser's Development Tools to view the network transfer speed of the requests.
Each callback will corresponds to a `POST /_dash-update-component`. The contents of the request will 
indicate the inputs and therefore which callback the request is associated with.

**Improving Callback Network Transfer Performance**

There are two ways to improve callback network transfer performance:

1. Reduce the size of the inputs, outputs and state of a callback. This can be done with strategies like:

    - Aggregating or binning your data in Python before displaying it a `dcc.Graph` or `dash_table.DataTable`.
    - Using an alternative visualization routine that displays an aggregate or summary of data instead of every individual data point.
    - Visualizing aggregated data via [Dash with Datashader](/holoviews).
    - Replacing `dcc.Store` or hidden divs with a server-side cache via the ["Caching and Signaling" method](/sharing-data-between-callbacks).
2. Reduce the number of times a callback is fired. This can be done with strategies like:

    - [Clientside callbacks](/clientside-callbacks)
    - Changing the UI to update less frequently from user interaction. For example, instead of updating on every keypress of a `dcc.Input`, update the UI when the user clicks a button and pass the value of the `dcc.Input` via [`State`](/basic-callbacks).
    - Replacing `dcc.Store` or hidden divs with a server-side cache via the ["Caching and Signaling" method](/sharing-data-between-callbacks).
    - Combining multiple callbacks into a single callback with [multiple outputs](/basic-callbacks).

**Data Fetching to External Datastores**

Data from an external datastore like a database or object store like S3 is transferred over the network.

Unless you are using Dash Enterprise Workspaces, the network path from your workstation's
environment to your datastore is different than the network path from Dash Enterprise to the datastore.

This has a few implications:

1. The VMs that are running Dash Enterprise apps need to have network access to your data store. You can verify this by using a Dash Enterprise Workspace.
2. The network speed may be different when deploying your app. Usually, the network transfer speed is _faster_ as the Dash Enterprise VMs are frequently "closer" to the underlying datastore in your organization's VPC.

### Working with Large Data Files

If your app can read directly from data files (rather than a database or an API), then you have three options for reading these files in a deployed application:

- **Commit the files** into your project folder. Projects with large 
    data files can become difficult to share between systems & people and 
    so we recommend trying to keep your project less than 100MB. We 
    recommend trying the **Parquet** data format to make your data files 
    smaller and faster to read. A 200MB CSV can be saved as a 40MB Parquet 
    file and read in 50ms instead of 3.5s.
- **Copy the files** onto the Dash Enterprise server and 
    [map a directory from your server to the Dash app container](/dash-enterprise/map-local-directories).
    You may need to discuss this option with your IT admin to gain access to your server 
    or to have them transfer files for you.
    This is not yet available on Dash Enterprise Kubernetes.
- **Store the data** on a cloud service like AWS S3 or Azure Blob Storage. Download the data files on-the-fly within a callback, on deployment with a [`postdeploy` command](/dash-enterprise/application-structure), or in a background schedule with `Celery` while mapping the directories between containers (see "Ephemeral File Systems" below).


### Working with Redis or Postgres

Dash Enterprise enables you to create and link Redis and Postgres databases to your application
via the App Manager user interface.

Once linked, these databases are accessible within your code via:

- The `REDIS_URL` environment variable for the Redis database
- The `DATABASE_URL` environment variable for the Postgres database

### Private Packages

If your app depends on private dependencies, see our 
[Private Packages Doc](/dash-enterprise/private-packages)
for details.

### Ephemeral File Systems

Each command listed in your Procfile is executed in a separate Docker 
container and Docker containers have isolated file systems.

When you deploy a Dash app, it is run in a set of new containers.
So, data that is written to the file system won't necessarily be available
during the next deployment nor will be available between processes (like between the `web` process and the `worker` process).

To workaround this limitation, you have three options:

1. Save the data to an external data store
2. Save the data to a Redis or Postgres database onboard Dash Enterprise. This feature is not yet available on Dash Enterprise Kubernetes.
3. [Map a directory](/dash-enterprise/map-local-directories) from the underlying server's non-ephemeral file system to the container. This feature is not yet available on Dash Enterprise Kubernetes.

### Authentication and Authorization

Apps deployed on Dash Enterprise can access the username of the currently loggged in visitor of the Dash application 
via the `dash-enterprise-auth` package:

```python
import dash_enterprise_auth

@app.callback(...)
def update(...):
    username = dash_enterprise_auth.get_username()  # only available within callbacks
    user_data = dash_enterprise_auth.get_user_data()  # only available within calblacks
```

This data can be used to create row-level-security logic where the username is used within the Python logic
or the database query to display data associated with that particular user.

### Request Timeouts

Apps deployed on Dash Enterprise are subject to a 30 second request timeout by default.
This is to prevent long-running or stuck requests from hanging the app's processes and preventing further requests.

Request timeouts are encountered when running your app callbacks. So, if your callback takes longer than 30 seconds
it will timeout by default and the update will not be displayed to the user.

To get around this, you have a few options:

1. Speed up your application code so that it takes less than 30 seconds to run
2. Split up long callbacks into multiple chained callbacks, storing intermediate data in a `dcc.Store` or
   in a server-side cache (see ["Caching and Signaling"](/sharing-data-between-callbacks)
3. Run long-running tasks in a Job Queue instead. See the "Background Task Queue" Sample Application on your Dash Enterprise server
   at https://<your-dash-enterprise-server>/Docs/templates.
4. Increase two timeouts:
   a. The built-in proxy timeout in the Dash Enterprise Server Manager. Your admin will need to adjust this setting.
   b. The default gunicorn timeout with e.g. ` gunicorn app:server --timeout 120`.
   
   Be aware of the performance limitations of this method: more CPU processes and workers will be utilized while
   handling long-running requests and it will be more likely that your app will "run out" of the
   available CPU processes and workers while multiple users interact with your app. You will likely need to increase
   the number of workers with gunicorn's `--workers` argument.

### Startup Timeouts

`gunicorn` is used to run your application on deployments. `gunicorn` has a default worker startup timeout of 30 seconds.

If your application takes longer than 30 seconds to boot-up (that is, to be ready to handle new requests), then the workers will timeout and restart.

To get around this, increase the boot-up timeout with the `--timeout` argument in your `Procfile`:
```
web: gunicorn app:server --timeout 60
```

Also, consider using a [CHECKS](/dash-enterprise/application-structure) to prevent downtime during long boot-up periods.

### URL Routing

Dash Enterprise applications are accessible under a separate URL path.

That is, instead of accessing the app at e.g. `http://localhost:8050`, you access the app at `https://<your-dash-enterprise>.com/<your-dash-app-name>`. 

The `/<your-dash-app-name>` is the path that we are referring to.

When dealing with anything to do with URL paths, we recommend using built-in functions instead of constructing these URLs manually.
These functions account for the differences between path-less URLs in local environments vs path-aware URLs in deployed environments.

These functions include:
- `app.get_relative_path('/page-two')` for creating URL paths used in links (`dcc.Link('Home', href=app.get_relative_path('/')` or `html.A('Home', href=app.get_relative_path('/')`) or image or video assets (`html.Img(src=app.get_relative_path('/assets/logo.png')`)
- `app.strip_relative_path(pathname)` for stripping the relative path out of the pathname. Used multi-page app callbacks that respond to `dcc.Location`

See the "Multi-Page Dash App with a Header" sample app in `https://<your-dash-enterprise>/Docs/templates`.

### Python Version

The Python version that you use locally may be different from the Python version used by Dash Enterprise. 

See the default Python version in your version of Dash Enterprise
and how to customize this with `runtime.txt` in the [Application Structure](/dash-enterprise/application-structure) documentation.

### Server Resources (CPU, RAM, Disk, Network)

Dash Enterprise runs your application on a remote VM.

This server may have more or less CPU, RAM, Disk Space & Write/Read Speed, Network Speed than your local environment.

This may cause your app to run faster or slower than your local environment.

If the server is under-provisioned, there may not be enough memory on the platform to run your Dash application. 
On Dash Enterprise on a Single Server, this can cause the server downtime.
On Dash Enterprise Kubernetes, this can cause the app to not be deployed.

On Dash Enterprise Kubernetes, you will need to allocate enough memory and CPU for your particular application via the "Resources" tab
after initializing your app in the Dash Enterprise App Manager.

If your application requires a significant amount of memory (>2GB), you may consider asking your administrator about the server's underlying
resources to ensure there is enough memory.

Measure the memory of your Dash application by using tools available for your operating system like `htop` (Linux & Mac) or
Process Manager on Windows.

Note that if your application is run with multiple workers with `gunicorn`, the memory may be more than what you see when 
running the application with `python app.py` as each worker will allocate its own memory.
This memory can be partially shared with the `--preload` option.

### Package Versions

Ensure that your local environment is using the same Python package versions as the deployed application by
providing version numbers in your `requirements.txt` file. See [Application Structure](/dash-enterprise/application-structure)
for details.

### Daily Restarts & Memory and CPU Limits (Kubernetes)

In Dash Enterprise Kubernetes, your application can restart more frequently than when running locally:
1. Daily Restarts - Dash Enterprise Kubernetes restarts your application daily to prevent
long-running memory leaks or other subtle bugs that can occur with long-running processes.
2. Out-of-memory Restarts - If the application consumes more memory than what it has been allocated,
then Dash Enterprise will restart the application. This can be desirable if there is a memory leak or
surprising if simply enough memory was not allocated.

There are also CPU limits. Exceeding the CPU limit will not restart the app however it will slow the application down.

### Dash Enterprise Application Capabilities

Dash Enterprise includes access to several commercial packages that can be incorporated into your Dash application.
Visit `https://<your-dash-enterprise>.com/Docs` for commercial documentation and installation. These capabilities include libraries like:

- `dash-design-kit` for theming and building the layout of your Dash app
- `dash-snapshots` for saving point-in-time views of your app's state and generating structured reports
- `dash-embedded` for embedding Dash apps in 3rd party websites without Iframes
- `dash-notes` for allowing end-users to annotation and comment on your app
and more.

### 3rd Party Proxy Servers

In some cases, Dash Enterprise is configured by administrators with unsupported, untested, or misconfigured proxy servers.

Sometimes these servers can cause issues forwarding requests to Dash Enterprise.

This can cause issues when installing packages over the network during deployment or while transferring callback data.
